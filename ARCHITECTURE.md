# Архитектура приложения ProjectVoice

## Обзор

ProjectVoice использует **модульную и плагинную архитектуру**, которая обеспечивает:
- Четкое разделение ответственности
- Легкое добавление новых функций
- Переиспользование кода
- Независимую разработку модулей
- Расширяемость через плагины

## Структура проекта

```
src/
├── core/                 # Ядро приложения
│   ├── api/             # API клиент
│   ├── socket/          # Socket.io клиент
│   ├── store/           # Базовые stores (auth, theme, notifications)
│   ├── config/          # Конфигурация
│   ├── plugin/          # Система плагинов
│   ├── module/          # Система модулей
│   └── types/           # Базовые типы
│
├── modules/             # Бизнес-модули
│   ├── auth/            # Модуль аутентификации
│   ├── voice/           # Модуль голосового общения
│   ├── messaging/       # Модуль сообщений
│   └── ...
│
├── features/            # Feature-based компоненты (legacy, постепенно мигрируем)
│   ├── voice/
│   ├── messaging/
│   └── ...
│
├── plugins/             # Плагины
│   ├── example-plugin/
│   └── ...
│
├── shared/              # Общие компоненты и утилиты
│   ├── components/      # Переиспользуемые UI компоненты
│   ├── hooks/           # Переиспользуемые хуки
│   ├── utils/           # Утилиты
│   └── types/           # Общие типы
│
├── pages/               # Страницы приложения
│   ├── auth/
│   ├── main/
│   ├── channelPage/
│   └── ...
│
├── app/                 # Инициализация приложения
│   ├── initialize.ts    # Регистрация модулей и плагинов
│   └── routes.tsx       # Сборка маршрутов
│
└── styles/              # Глобальные стили
```

## Слои архитектуры

### 1. Core Layer (Ядро)

**Назначение**: Базовые сервисы и инфраструктура, используемые всеми модулями.

**Принципы**:
- Core не зависит от модулей
- Все модули могут использовать core
- Содержит только базовую функциональность
- Нет бизнес-логики

**Компоненты**:
- `api/apiClient` - HTTP клиент
- `socket/SocketClient` - Socket.io клиент
- `store/` - Базовые stores (auth, theme, notifications)
- `config/` - Конфигурация приложения
- `plugin/PluginManager` - Менеджер плагинов
- `module/ModuleManager` - Менеджер модулей

### 2. Modules Layer (Модули)

**Назначение**: Бизнес-логика, организованная по функциональным областям.

**Принципы**:
- Каждый модуль независим
- Модули могут зависеть от core и shared
- Модули регистрируются через ModuleManager
- Модули могут предоставлять маршруты

**Структура модуля**:
```
modules/auth/
├── components/      # Компоненты модуля
├── services/        # Сервисы модуля
├── store/           # Stores модуля (если нужны)
├── hooks/           # Хуки модуля
├── types/           # Типы модуля
├── index.ts         # Публичный API модуля
└── module.ts        # Регистрация модуля
```

**Пример модуля**:
```typescript
export const authModule: IModule = {
    id: 'auth',
    name: 'Authentication Module',
    version: '1.0.0',
    routes: [
        {
            path: '/auth',
            component: Auth,
            protected: false,
        },
    ],
    async initialize() {
        // Инициализация модуля
    },
    async destroy() {
        // Очистка при удалении
    },
};
```

### 3. Plugins Layer (Плагины)

**Назначение**: Расширяемая функциональность, которая может быть добавлена или удалена.

**Принципы**:
- Плагины независимы от модулей
- Плагины могут зависеть от других плагинов
- Плагины регистрируются через PluginManager
- Плагины могут расширять функциональность модулей

**Структура плагина**:
```
plugins/example-plugin/
├── plugin.ts        # Реализация плагина
├── index.ts         # Регистрация плагина
└── README.md        # Документация
```

**Пример плагина**:
```typescript
export const examplePlugin: IPlugin = {
    id: 'example-plugin',
    name: 'Example Plugin',
    version: '1.0.0',
    dependencies: [],
    async initialize() {
        // Инициализация плагина
    },
    async destroy() {
        // Очистка при удалении
    },
};
```

### 4. Shared Layer (Общее)

**Назначение**: Переиспользуемые компоненты, утилиты и типы.

**Принципы**:
- Shared не зависит от модулей
- Shared может зависеть от core
- Все компоненты должны быть переиспользуемыми
- Нет бизнес-логики

**Компоненты**:
- `components/` - UI компоненты (Modal, ClickableAvatar и т.д.)
- `hooks/` - Переиспользуемые хуки
- `utils/` - Утилиты (cookie, форматирование и т.д.)
- `types/` - Общие типы

## Жизненный цикл приложения

### 1. Инициализация

```typescript
// src/app/initialize.ts
export async function initializeApp() {
    // 1. Включаем MobX
    enableMobX();
    
    // 2. Регистрируем модули
    moduleManager.register(authModule);
    moduleManager.register(voiceModule);
    
    // 3. Инициализируем модули (с учетом зависимостей)
    await moduleManager.initializeAll();
    
    // 4. Инициализируем плагины
    await pluginManager.initializeAll();
}
```

### 2. Регистрация маршрутов

Маршруты автоматически собираются из зарегистрированных модулей:

```typescript
// src/app/routes.tsx
const moduleRoutes = moduleManager.getRoutes();
// Создаем роутер с маршрутами из модулей
```

### 3. Уничтожение

```typescript
export async function destroyApp() {
    await pluginManager.destroyAll();
    await moduleManager.destroyAll();
}
```

## Зависимости между слоями

```
┌─────────────┐
│   Plugins   │
└──────┬──────┘
       │
┌──────▼──────┐
│   Modules   │
└──────┬──────┘
       │
┌──────▼──────┐     ┌──────────┐
│    Core     │◄────│  Shared   │
└─────────────┘     └──────────┘
```

**Правила зависимостей**:
- ✅ Modules → Core, Shared
- ✅ Plugins → Core, Shared
- ✅ Shared → Core
- ❌ Core → Modules, Plugins, Shared
- ❌ Modules → Modules (через зависимости в module.ts)

## Миграция существующего кода

### Этап 1: Core Layer ✅
- [x] Создан core слой
- [x] Перенесены базовые сервисы (API, Socket)
- [x] Перенесены базовые stores (auth, theme, notifications)
- [x] Создана система плагинов и модулей

### Этап 2: Modules Layer (в процессе)
- [x] Создан модуль auth
- [x] Создан модуль voice
- [x] Создан модуль messaging
- [ ] Миграция остальных features в модули

### Этап 3: Shared Layer
- [x] Существующие shared компоненты
- [ ] Реорганизация shared структуры

### Этап 4: Plugins
- [x] Создана система плагинов
- [x] Создан пример плагина
- [ ] Создание реальных плагинов

## Преимущества архитектуры

1. **Модульность**: Каждый модуль независим и может разрабатываться отдельно
2. **Расширяемость**: Легко добавлять новые функции через модули и плагины
3. **Переиспользование**: Общие компоненты в shared, базовые сервисы в core
4. **Тестируемость**: Каждый модуль можно тестировать изолированно
5. **Масштабируемость**: Легко добавлять новые модули без изменения существующих
6. **Поддерживаемость**: Четкая структура упрощает поддержку кода

## Следующие шаги

1. Завершить миграцию features в modules
2. Создать больше плагинов (analytics, themes, shortcuts)
3. Добавить систему событий для коммуникации между модулями
4. Добавить систему конфигурации модулей
5. Создать CLI для генерации новых модулей и плагинов

